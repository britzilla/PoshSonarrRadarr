
function Invoke-ApiMethod {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true, Position=0)] [ValidateSet('Sonarr', 'Radarr')] [string] $Type,
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)] [string] $Path,
        [Parameter(Mandatory=$false)] [hashtable] $Query = $null,
        [Parameter(Mandatory=$false)] [Microsoft.PowerShell.Commands.WebRequestMethod] $Method = 'Get',
        [Parameter(Mandatory=$false)] [PSObject] $Body,
        [Parameter(Mandatory=$false)] [string] $ExpandJsonProperty = $null
    )
    begin {
        # Hide progress bar presented by Invoke-WebRequest
        $ProgressPreference = 'SilentlyContinue'
        # Assign $BaseUri and $ApiKey from config file based on the $Type parameter ('Sonarr' or 'Radarr')
        $BaseUri = [Uri] $Script:Config.$Type.BaseUri
        $ApiKey = $Script:Config.$Type.ApiKey
        # System.Web needs to be added in Windows PowerShell
        Add-Type -AssemblyName System.Web
    }
    process {
        # Define parameters for constructing a UriBuilder object using the supplied Uri, Path, and Query
        # Note: The supplied Uri should already contain the port number, if applicacable
        $EncodedQuery = [System.Web.HttpUtility]::ParseQueryString('')
        $Query.Keys.ForEach{ $EncodedQuery[$_] = $Query[$_] }
        $UriBuilderProps = @{
            Path    = $BaseUri.AbsolutePath + $Path
            Query   = $EncodedQuery.ToString()
        }
        # Define Invoke-WebRequest parameters using the supplied $Method and Uri object generated by our UriBuilder
        # Include ApiKey in the request headers
        $RequestParam = @{
            Headers = @{ 'X-Api-Key' = $ApiKey }
            Method  = $Method
            Uri     = (New-Object System.UriBuilder $BaseUri -Property $UriBuilderProps).Uri
        }
        # If $Body was supplied, convert it to JSON and set the ContentType header to application/json
        if( $PSBoundParameters.ContainsKey('Body') ) {
            $RequestParam += @{
                Body        = $Body | ConvertTo-Json -Depth 10 -EscapeHandling EscapeNonAscii -AsArray:($Body -is [array])
                ContentType = 'application/json'
            }
        }
        Write-Verbose "Calling $Type API using parameters:"
        Write-Verbose ( $RequestParam.Keys.ForEach{ '{0}: {1}' -f $_, $RequestParam[$_] } -join ', ' )
        try {
            $Result = Invoke-WebRequest @RequestParam
            $ResultObject = [ordered] @{
                StatusCode        = $Result.StatusCode
                StatusDescription = $Result.StatusDescription
            }
            if ($null -eq $ExpandJsonProperty) {
                $ResultObject["Content"] = $Result.Content | ConvertFrom-Json
            }
            else {
                $ResultObject["Content"] = $Result.Content | ConvertFrom-Json | Select-Object -ExpandProperty $ExpandJsonProperty | Write-Output
            }
        }
        catch {
            $ResultObject = [ordered] @{
                StatusCode        = [int] $Global:Error[0].Exception.Response.StatusCode
                StatusDescription = [string] $Global:Error[0].Exception.Response.StatusCode
                Content           = $Global:Error[0].ErrorDetails.Message
            }
        }
        finally {
            [PSCustomObject] $ResultObject | Write-Output
        }
    }
}
